<!DOCTYPE html>
<html>

<head>
  <meta charset="UTF-8">
  <title>
    Motan源码解读-serialize - 
    郑大侠的博客
  </title>
  <link rel="stylesheet" href="/css/base.css">
  <link rel="stylesheet" href="/css/sidebar.css">
</head>

<body>
  <div class="wrap">

    <div class="sidebar">
  
  <div class="face">
    <div img-src=""></div>
  </div>

  <h1 class="author">DempeZheng</h1>
  <p class="desc">請更固執，將自己謀生與擅長的事情做到最好</p>
  
  
  
  
  
  
  
  
  <div class="pages">
    <a class="" href="/about-me">ABOUT ME</a>
    <a class="" href="/links">LINKS</a>
  </div>
  
  <div class="categories">
  
    
    
    <a class="" href="/">All Categories</a>
    
    
      
      
      
      
      
      
      
        
      
    
      <a class="" href="/categories/IM开发日记/">IM开发日记</a>
      
    
      
      
      
      
      
      
      
        
          
        
      
    
      <a class="active" href="/categories/Motan源码解读/">Motan源码解读</a>
      
    
      
      
      
      
      
      
      
        
      
    
      <a class="" href="/categories/并发编程/">并发编程</a>
      
    
      
      
      
      
      
      
      
        
      
    
      <a class="" href="/categories/cache/">cache</a>
      
    
  </div>

  
  
  <div class="sns">
    
  </div>
  
  <script src="/js/jquery.min.js"></script>
  <script src="/js/sidebar.js"></script>
  
</div>
    
    <link rel="stylesheet" href="/css/post.css">
    <link rel="stylesheet" href="/css/markdown.css">
    <link rel="stylesheet" href="/css/highlight/print-code.css">
    
    <div class="main">
      <div class="post">
        <h1>Motan源码解读-serialize</h1>
        <h2>2016-9-22</h2>
        <hr>
        <div class="content markdown"><h3 id="motan-序列化"><a href="#motan-序列化" class="headerlink" title="motan 序列化"></a>motan 序列化</h3><h4 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h4><blockquote>
<p><strong>序列化：</strong> 将数据结构或对象转换成二进制串的过程。<br><strong>反序列化：</strong>将在序列化过程中所生成的二进制串转换成数据结构或者对象的过程。</p>
</blockquote>
<p>motan 将RPC<code>请求中的参数、结果等对象进行序列化与反序列化</code>，即进行对象与字节流的互相转换；默认使用对java更友好的hessian2进行序列化。（注意序列化的是请求的参数，和返回的结果，其他的地方不需要序列化）</p>
<p>一个rpc框架的性能主要取决于：线程模型，IO模型，序列化三个方面。（对于有gc机制的jvm来说，零拷贝也很关键）<br>所以一个性能优异的序列化对于rpc是非常重要的。（这里的序列化和反序列化仅仅涉及到请求中的参数、结果等对象，协议其他的信息的序列化见后续的codec章节）</p>
<p>motan会对client端发送的request的请求参数对象进行序列化，也会对服务端下发给response对象进行序列化，如下图所示：</p>
<p><img src="/code/images//motan/motan-register-server-client.jpg" alt=""></p>
<h4 id="motan目前支持两种序列化："><a href="#motan目前支持两种序列化：" class="headerlink" title="motan目前支持两种序列化："></a>motan目前支持两种序列化：</h4><ul>
<li>hession2</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">&lt;motan:protocol serialization=&quot;hessian2&quot; /&gt;</div></pre></td></tr></table></figure>
<ul>
<li>fastjson</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">&lt;motan:protocol serialization=&quot;fastjson&quot; /&gt;</div></pre></td></tr></table></figure>
<h3 id="各种序列化性能对比"><a href="#各种序列化性能对比" class="headerlink" title="各种序列化性能对比"></a>各种序列化性能对比</h3><p><img src="/images/motan/serialize.png" alt=""></p>
<p>我们可以发现fastjson的序列化性能和thrift和protobuf差异已经不太大了，明显好过hession（当然上图比较的不知道hession的版本，可能不准确）<br>dubbo是有针对hession单独做优化的，但是motan默认使用hession，且没做优化。</p>
<h3 id="motan序列化的实现"><a href="#motan序列化的实现" class="headerlink" title="motan序列化的实现"></a>motan序列化的实现</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 这个可以可以扩展的，也就是你可以扩展motan用你想要的序列化方式</span></div><div class="line"><span class="meta">@Spi</span>(scope=Scope.PROTOTYPE)</div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Serialization</span> </span>&#123;</div><div class="line">	<span class="comment">// 将对象序列话称字节数组</span></div><div class="line">	<span class="keyword">byte</span>[] serialize(Object obj) <span class="keyword">throws</span> IOException;</div><div class="line">	<span class="comment">// 将字节数组反序列化成对象</span></div><div class="line">	&lt;T&gt; <span class="function">T <span class="title">deserialize</span><span class="params">(<span class="keyword">byte</span>[] bytes, Class&lt;T&gt; clz)</span> <span class="keyword">throws</span> IOException</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>具体的实现要看hession2和fastjson了。</p>
<p>motan序列化&amp;反序列化仅仅包含了请求参数和返回对象，其他对象的编解码，我们且看下一篇文章。</p>
<hr>
<p>后记：</p>
<p>1.fastjson确实够快，使用也挺方便的。</p>
<p>2.如果我们需要扩展motan实现thrift或者protobuf还需要hession或者fastjson来辅助序列化吗？</p>
<p>首先hession可以排除，使用hession跨语言调用就比较难实现了。<br>那么需要辅助的fastjson来序列化吗？没必要。</p>
<div>
        <div id="disqus_thread"></div>
      </div>
    </div>

  </div>
  
  <script src="/js/jquery.min.js"></script>
  <script src="/js/post.js"></script>
  <script src="/js/markdown.js"></script>
  <script src="//undefined.disqus.com/embed.js"></script>
    
</body>
</html>