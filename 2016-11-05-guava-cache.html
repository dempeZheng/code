<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  <title>Guava Cache 分析 | 郑大侠的博客</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta name="description" content="Guava Cache 分析guava的单线程回源缓存的更新有两种方法:

被动更新：先从缓存获取，没有则回源获取，再更新缓存；
主动更新：发现数据改变后直接更新缓存（在分布式场景下，不容易实现）

在高并发环境，被动回源是需要注意的。问题：高并发场景下，大量请求在同一时间回源，大量的请求同一时间穿透到后端，容易引起后端服务崩溃（也容易引起并发问题）。
guava cache解决办法：guava">
<meta property="og:type" content="article">
<meta property="og:title" content="Guava Cache 分析">
<meta property="og:url" content="http://code.zhizus.com/2016-11-05-guava-cache.html">
<meta property="og:site_name" content="郑大侠的博客">
<meta property="og:description" content="Guava Cache 分析guava的单线程回源缓存的更新有两种方法:

被动更新：先从缓存获取，没有则回源获取，再更新缓存；
主动更新：发现数据改变后直接更新缓存（在分布式场景下，不容易实现）

在高并发环境，被动回源是需要注意的。问题：高并发场景下，大量请求在同一时间回源，大量的请求同一时间穿透到后端，容易引起后端服务崩溃（也容易引起并发问题）。
guava cache解决办法：guava">
<meta property="og:updated_time" content="2016-11-05T12:41:29.800Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Guava Cache 分析">
<meta name="twitter:description" content="Guava Cache 分析guava的单线程回源缓存的更新有两种方法:

被动更新：先从缓存获取，没有则回源获取，再更新缓存；
主动更新：发现数据改变后直接更新缓存（在分布式场景下，不容易实现）

在高并发环境，被动回源是需要注意的。问题：高并发场景下，大量请求在同一时间回源，大量的请求同一时间穿透到后端，容易引起后端服务崩溃（也容易引起并发问题）。
guava cache解决办法：guava">
  
    <link rel="alternate" href="/atom.xml" title="郑大侠的博客" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.png">
  
  
    <link href="//fonts.googleapis.com/css?family=Source+Code+Pro" rel="stylesheet" type="text/css">
  
  <link rel="stylesheet" href="/css/style.css">
  

</head>

<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
     <a class="back-btn" href="/">
       <i class="fa fa-camera-retro"></i>
     </a>
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">

        <a href="/" id="logo">郑大侠的博客</a>
      </h1>
      
        <h2 id="subtitle-wrap">
          <a href="/" id="subtitle">DempeZheng&#39;S Blog</a>
        </h2>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
          <a id="nav-rss-link" class="nav-icon" href="/atom.xml" title="RSS Feed"></a>
        
        <a id="nav-search-btn" class="nav-icon" title="Search"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" results="0" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="http://code.zhizus.com"></form>
      </div>
    </div>
  </div>
</header>
      <div class="outer">
        <section id="main"><article id="post-2016-11-05-guava-cache" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2016-11-05-guava-cache.html" class="article-date">
  <time datetime="2016-11-04T16:00:00.000Z" itemprop="datePublished">2016-11-05</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/cache/">cache</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 class="article-title" itemprop="name">
      Guava Cache 分析
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="Guava-Cache-分析"><a href="#Guava-Cache-分析" class="headerlink" title="Guava Cache 分析"></a>Guava Cache 分析</h2><h3 id="guava的单线程回源"><a href="#guava的单线程回源" class="headerlink" title="guava的单线程回源"></a>guava的单线程回源</h3><p>缓存的更新有两种方法:</p>
<ul>
<li>被动更新：先从缓存获取，没有则回源获取，再更新缓存；</li>
<li>主动更新：发现数据改变后直接更新缓存（在分布式场景下，不容易实现）</li>
</ul>
<p>在高并发环境，被动回源是需要注意的。<br>问题：高并发场景下，大量请求在同一时间回源，大量的请求同一时间穿透到后端，容易引起后端服务崩溃（也容易引起并发问题）。</p>
<p>guava cache解决办法：<br>guava cache保证单线程回源，对于同一个key，只让一个请求回源load，其他线程阻塞等待结果。同时，在Guava里可以通过配置expireAfterAccess/expireAfterWrite设定key的过期时间，key过期后就单线程回源加载并放回缓存。</p>
<p>这样通过Guava Cache简简单单就较为安全地实现了缓存的被动更新操作。</p>
<p>但是如果对于同一时间大量不同的key同时过期，造成大量不同的key同时回源，这种怎么解决呢？</p>
<blockquote>
<p>guava cache实现类似ConcurrentHashMap，维护segment数组，每个segment独享一个锁，ConcurrentHashMap是通过这种机制来实现分段锁，ConcurrentHashMap默认分了16个segment；<br>guava Cache默认是4个segment，故guava cache的并发级别默认是4个，也就是说默认情况下，即便是大量不同的key同时过期，最多只也有4个线程并发回源，理论上不会给后端造成过大的压力。</p>
</blockquote>
<h3 id="guava-refresh和expire刷新机制"><a href="#guava-refresh和expire刷新机制" class="headerlink" title="guava refresh和expire刷新机制"></a>guava refresh和expire刷新机制</h3><ul>
<li>expireAfterAccess: 当缓存项在指定的时间段内没有被读或写就会被回收。</li>
<li>expireAfterWrite：当缓存项在指定的时间段内没有更新就会被回收。</li>
<li>refreshAfterWrite：当缓存项上一次更新操作之后的多久会被刷新。</li>
</ul>
<p>仅仅使用 expireAfterWrite或者expireAfterAccess就可以实现缓存定时过期，但是频繁的过期会造成频繁的单线程回源，然而guava cache回源的时候会独占一个segment的锁，对于同一个segment的其他的读操作 处于loading状态的则会继续等待，value expire或者为null的key则会阻塞等待segment的锁。</p>
<p> expireAfterWrite或者expireAfterAccess的实现在数据回源的时候会让请求block住，以获取最新的值。数据实时性保证的较好，但是阻塞住请求对于一些响应要求严苛的业务可能是没办法接受的。那有没有解决的办法呢？</p>
<p>我们且看refreshAfterWrite：</p>
<p>refreshAfterWrite通过定时刷新可以让缓存项保持可用。缓存项只有在被检索时才会真正刷新（如果CacheLoader.refresh实现为异步，那么检索不会被刷新拖慢）。也是保证同一个segment的单线程回源，但是与expireAfterWrite不同的是：其他线程访问loading状态的key时，仅仅稍微等一会，没有等到就返回旧值，整个请求就比较平滑。<br>与此同时，也引入了一个问题，refreshAfterWrite策略下，如果一个key长期没有被访问，就有可能会访问到很久之前的旧值。例如refreshAfterWrite(5),5s刷新一次，如果1min内，这个key都没有被访问，那么1min之后访问这个key，仍然有可能访问到旧数据，尽管我们设置了5s刷新一次。（guava cache并没单独的线程来处理刷新的逻辑，而是通过读操作来触发清理工作）</p>
<p>对于这个问题有没有这种的办法呢？<br>guava cache支持我们同时使用expireAfterWrite&amp;refreshAfterWrite，我们既可以通过组合的策略既保证性能，又保证不要读取到太旧的数据。<br>比如我们有需求：要求请求必须平滑，而且不能读到5s之前的旧数据。</p>
<p>我们可以如下设置来满足需求：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">LoadingCache&lt;String, String&gt; cache;</div><div class="line">   cache = CacheBuilder</div><div class="line">           .newBuilder()</div><div class="line">           .refreshAfterWrite(4L, TimeUnit.SECONDS)</div><div class="line">           .expireAfterWrite(5L, TimeUnit.SECONDS)</div><div class="line">           .build(loader);</div></pre></td></tr></table></figure>
<p> <code>expireAfterWrite(5L, TimeUnit.SECONDS)</code>能保证不会读到5s之前的旧数据，<code>refreshAfterWrite(4L, TimeUnit.SECONDS)</code>能保证大部分请求都在4s左右被刷新，小部分访问量较少的在5s的时候通过expireAfterWrite策略重新被回源。</p>
<h3 id="guava后台异步刷新"><a href="#guava后台异步刷新" class="headerlink" title="guava后台异步刷新"></a>guava后台异步刷新</h3><p>refreshAfterWrite的刷新调用的是reload，reload的默认实现是在当前线程里面reload，也会造成一些卡顿，如果希望异步reload，需要重载这个方法。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">@GwtIncompatible // Futures</div><div class="line"> public ListenableFuture&lt;V&gt; reload(K key, V oldValue) throws Exception &#123;</div><div class="line">   checkNotNull(key);</div><div class="line">   checkNotNull(oldValue);</div><div class="line">   return Futures.immediateFuture(load(key));//当前线程调用load，会造成当前线程的卡顿，如果不接受卡顿，需要重载这个方法</div><div class="line"> &#125;</div></pre></td></tr></table></figure></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://code.zhizus.com/2016-11-05-guava-cache.html" data-id="ciy7c87u4000z0gq6yo5xofxs" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
    
<nav id="article-nav">
  
  
    <a href="/2016-11-05guava-cache-info.html" id="article-nav-older" class="article-nav-link-wrap">
      <strong class="article-nav-caption">Older</strong>
      <div class="article-nav-title">Guava Cache使用示例</div>
    </a>
  
</nav>

  
</article>

</section>
        
          <aside id="sidebar">
  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Categories</h3>
    <div class="widget">
      <ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/IM开发日记/">IM开发日记</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/Motan源码解读/">Motan源码解读</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/cache/">cache</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/并发编程/">并发编程</a></li></ul>
    </div>
  </div>


  
    

  
    
  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Archives</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2016/11/">November 2016</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2016/09/">September 2016</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Recent Posts</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2016-11-05-guava-cache.html">Guava Cache 分析</a>
          </li>
        
          <li>
            <a href="/2016-11-05guava-cache-info.html">Guava Cache使用示例</a>
          </li>
        
          <li>
            <a href="/2017-01-21newyear.html">Guava Cache使用示例</a>
          </li>
        
          <li>
            <a href="/2016-09-23-motan-codec.html">Motan源码解读-codec</a>
          </li>
        
          <li>
            <a href="/2016-09-23-motan-rpc.html">深入浅出Motan RPC</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      &copy; 2017 DempeZheng<br>
      Powered by <a href="http://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>
    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    

<script src="//ajax.googleapis.com/ajax/libs/jquery/2.0.3/jquery.min.js"></script>


  <link rel="stylesheet" href="/fancybox/jquery.fancybox.css">
  <script src="/fancybox/jquery.fancybox.pack.js"></script>


<script src="/js/script.js"></script>

  </div>
</body>
</html>